import Foundation

// MARK: - AttachedFile

/// Represents a file attached to an exam
struct AttachedFile: Codable, Identifiable, Equatable {
    let id: String
    let url: String
    let name: String
    
    init(id: String = UUID().uuidString, url: String, name: String) {
        self.id = id
        self.url = url
        self.name = name
    }
}

// MARK: - ExameModel

/// Represents a medical exam in the system.
/// This is the main entity for the Exames feature following VIPER architecture.
struct ExameModel: Codable, Identifiable, Equatable {
    
    // MARK: - Properties
    
    /// Unique identifier for the exam
    let id: String
    
    /// Name/type of the exam (e.g., "Hemograma Completo", "Raio-X Tórax")
    let nome: String
    
    /// Location where the exam was performed (e.g., "Hospital São Lucas", "Clínica Santa Maria")
    let localRealizado: String
    
    /// Name of the doctor who requested the exam
    let medicoSolicitante: String
    
    /// Reason or complaint that motivated the exam request
    let motivoQueixa: String
    
    /// Date when the exam was/will be performed (registration date)
    /// For scheduled exams, this is the future date when the exam will be performed
    /// For completed exams, this is the date when the exam was performed
    let dataCadastro: Date
    
    /// Date when the exam results will be ready (optional - only shown in detail view)
    let dataPronto: Date?
    
    /// Array of attached files (supports multiple files)
    let arquivosAnexados: [AttachedFile]
    
    /// DEPRECATED: Legacy single file URL (kept for backwards compatibility)
    let urlArquivo: String?
    
    /// DEPRECATED: Legacy single file name (kept for backwards compatibility)
    let nomeArquivo: String?
    
    // MARK: - Computed Properties
    
    /// Returns a friendly file name for display (legacy - uses first file or deprecated fields)
    var nomeArquivoExibicao: String? {
        // New: Use first file from array
        if !arquivosAnexados.isEmpty {
            return arquivosAnexados[0].name
        }
        
        // Legacy: If we have the original name, use it
        if let nome = nomeArquivo, !nome.isEmpty {
            return nome
        }
        
        // Legacy: Otherwise, try to extract from URL
        if let urlString = urlArquivo,
           let url = URL(string: urlString) {
            let lastPath = url.lastPathComponent
            
            if let decoded = lastPath.removingPercentEncoding {
                if let underscoreIndex = decoded.firstIndex(of: "_") {
                    let fileName = String(decoded[decoded.index(after: underscoreIndex)...])
                    return fileName
                }
                return decoded
            }
            return lastPath
        }
        
        return nil
    }
    
    /// Returns a formatted date string for display purposes
    var dataFormatada: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        formatter.locale = Locale(identifier: "pt_BR")
        return formatter.string(from: dataCadastro)
    }
    
    /// Returns true if the exam has an associated file (checks both new and legacy fields)
    var temArquivo: Bool {
        return !arquivosAnexados.isEmpty || (urlArquivo != nil && !(urlArquivo?.isEmpty ?? true))
    }
    
    /// Returns true if the exam is scheduled for a future date (dataCadastro > today)
    var isAgendado: Bool {
        return dataCadastro > Date()
    }
    
    /// Returns true if the exam is scheduled for today
    var isAgendadoHoje: Bool {
        let calendar = Calendar.current
        return calendar.isDateInToday(dataCadastro) && dataCadastro > Date()
    }
    
    /// Returns true if the exam was already performed (dataCadastro <= today)
    var isRealizado: Bool {
        return dataCadastro <= Date()
    }
    
    /// Returns true if the exam has no attached files (result pending)
    var isResultadoPendente: Bool {
        return !temArquivo
    }
    
    /// Returns the number of days until the exam (nil if already performed)
    var diasAteExame: Int? {
        guard dataCadastro > Date() else { return nil }
        let calendar = Calendar.current
        let components = calendar.dateComponents([.day], from: Date(), to: dataCadastro)
        return components.day
    }
    
    /// Returns a short summary of the exam for preview
    var resumo: String {
        return "\(nome) - \(localRealizado)"
    }
    
    // MARK: - Initializer
    
    /// Creates a new ExameModel instance
    /// - Parameters:
    ///   - id: Unique identifier (usually generated by Firebase)
    ///   - nome: Name/type of the exam
    ///   - localRealizado: Location where exam was/will be performed
    ///   - medicoSolicitante: Requesting doctor's name
    ///   - motivoQueixa: Reason for the exam
    ///   - dataCadastro: Date when exam was/will be performed (defaults to current date)
    ///   - dataPronto: Date when exam results will be ready (optional - only in detail view)
    ///   - arquivosAnexados: Array of attached files (supports multiple files)
    ///   - urlArquivo: DEPRECATED - Optional URL to exam file (for backwards compatibility)
    ///   - nomeArquivo: DEPRECATED - Optional file name (for backwards compatibility)
    init(
        id: String = UUID().uuidString,
        nome: String,
        localRealizado: String,
        medicoSolicitante: String,
        motivoQueixa: String,
        dataCadastro: Date = Date(),
        dataPronto: Date? = nil,
        arquivosAnexados: [AttachedFile] = [],
        urlArquivo: String? = nil,
        nomeArquivo: String? = nil
    ) {
        self.id = id
        self.nome = nome
        self.localRealizado = localRealizado
        self.medicoSolicitante = medicoSolicitante
        self.motivoQueixa = motivoQueixa
        self.dataCadastro = dataCadastro
        self.dataPronto = dataPronto
        self.urlArquivo = urlArquivo
        self.nomeArquivo = nomeArquivo
        
        // Migration: If old fields are provided but new array is empty, migrate them
        if arquivosAnexados.isEmpty, let url = urlArquivo, !url.isEmpty {
            let name = nomeArquivo ?? "Arquivo.pdf"
            self.arquivosAnexados = [AttachedFile(url: url, name: name)]
        } else {
            self.arquivosAnexados = arquivosAnexados
        }
    }
    
    // MARK: - Coding Keys
    
    /// Custom coding keys for Firebase Firestore compatibility
    enum CodingKeys: String, CodingKey {
        case id
        case nome
        case localRealizado = "local_realizado"
        case medicoSolicitante = "medico_solicitante"
        case motivoQueixa = "motivo_queixa"
        case dataCadastro = "data_cadastro"
        case dataPronto = "data_pronto"
        case dataAgendamento = "data_agendamento" // Legacy - for migration
        case arquivosAnexados = "arquivos_anexados"
        case urlArquivo = "url_arquivo"
        case nomeArquivo = "nome_arquivo"
    }
    
    // MARK: - Custom Decoding
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        id = try container.decode(String.self, forKey: .id)
        nome = try container.decode(String.self, forKey: .nome)
        localRealizado = try container.decode(String.self, forKey: .localRealizado)
        medicoSolicitante = try container.decode(String.self, forKey: .medicoSolicitante)
        motivoQueixa = try container.decode(String.self, forKey: .motivoQueixa)
        
        // Migration: If dataAgendamento exists, use it as dataCadastro (legacy support)
        if let legacyDataAgendamento = try? container.decode(Date.self, forKey: .dataAgendamento) {
            dataCadastro = legacyDataAgendamento
        } else {
            dataCadastro = try container.decode(Date.self, forKey: .dataCadastro)
        }
        
        // Decode optional dataPronto
        dataPronto = try? container.decode(Date.self, forKey: .dataPronto)
        
        // Decode legacy fields
        urlArquivo = try? container.decode(String.self, forKey: .urlArquivo)
        nomeArquivo = try? container.decode(String.self, forKey: .nomeArquivo)
        
        // Try to decode new format first
        if let files = try? container.decode([AttachedFile].self, forKey: .arquivosAnexados), !files.isEmpty {
            arquivosAnexados = files
        } else if let url = urlArquivo, !url.isEmpty {
            // Migration: If no new format but has legacy data, migrate it
            let name = nomeArquivo ?? "Arquivo.pdf"
            arquivosAnexados = [AttachedFile(url: url, name: name)]
        } else {
            arquivosAnexados = []
        }
    }
    
    // MARK: - Custom Encoding
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(nome, forKey: .nome)
        try container.encode(localRealizado, forKey: .localRealizado)
        try container.encode(medicoSolicitante, forKey: .medicoSolicitante)
        try container.encode(motivoQueixa, forKey: .motivoQueixa)
        try container.encode(dataCadastro, forKey: .dataCadastro)
        
        if let dataPronto = dataPronto {
            try container.encode(dataPronto, forKey: .dataPronto)
        }
        
        if !arquivosAnexados.isEmpty {
            try container.encode(arquivosAnexados, forKey: .arquivosAnexados)
        }
        
        if let urlArquivo = urlArquivo {
            try container.encode(urlArquivo, forKey: .urlArquivo)
        }
        
        if let nomeArquivo = nomeArquivo {
            try container.encode(nomeArquivo, forKey: .nomeArquivo)
        }
    }
}

// MARK: - ExameModel + Mock Data

extension ExameModel {
    /// Creates mock data for testing and preview purposes
    static func mock() -> ExameModel {
        return ExameModel(
            id: "123e4567-e89b-12d3-a456-426614174000",
            nome: "Hemograma Completo",
            localRealizado: "Hospital São Lucas",
            medicoSolicitante: "Dr. João Silva",
            motivoQueixa: "Rotina anual",
            dataCadastro: Date(),
            urlArquivo: "exames/user123/hemograma_2024.pdf"
        )
    }
    
    /// Creates an array of mock data for testing lists
    static func mockList() -> [ExameModel] {
        return [
            ExameModel(
                id: "1",
                nome: "Hemograma Completo",
                localRealizado: "Hospital São Lucas",
                medicoSolicitante: "Dr. João Silva",
                motivoQueixa: "Rotina anual",
                dataCadastro: Date().addingTimeInterval(-86400 * 7), // 7 days ago
                urlArquivo: "exames/user123/hemograma_2024.pdf"
            ),
            ExameModel(
                id: "2",
                nome: "Raio-X Tórax",
                localRealizado: "Clínica Santa Maria",
                medicoSolicitante: "Dra. Maria Santos",
                motivoQueixa: "Dor no peito",
                dataCadastro: Date().addingTimeInterval(-86400 * 3), // 3 days ago
                urlArquivo: "exames/user123/raio_x_2024.pdf"
            ),
            ExameModel(
                id: "3",
                nome: "Ressonância Magnética",
                localRealizado: "Hospital Central",
                medicoSolicitante: "Dr. Pedro Costa",
                motivoQueixa: "Investigação neurológica",
                dataCadastro: Date().addingTimeInterval(-86400 * 1), // 1 day ago
                urlArquivo: nil
            ),
            ExameModel(
                id: "4",
                nome: "Exame de Sangue",
                localRealizado: "Laboratório Lab+",
                medicoSolicitante: "Dr. Carlos Lima",
                motivoQueixa: "Check-up preventivo",
                dataCadastro: Date(),
                urlArquivo: "exames/user123/sangue_2024.pdf"
            )
        ]
    }
}

// MARK: - ExameModel + Validation

extension ExameModel {
    /// Validates if the model has all required fields filled
    /// - Returns: True if valid, false otherwise
    func isValid() -> Bool {
        return !nome.isEmpty &&
               !localRealizado.isEmpty &&
               !medicoSolicitante.isEmpty &&
               !motivoQueixa.isEmpty
    }
    
    /// Returns validation errors as an array of strings
    /// - Returns: Array of error messages (empty if valid)
    func validationErrors() -> [String] {
        var errors: [String] = []
        
        if nome.isEmpty {
            errors.append("Nome do exame é obrigatório")
        }
        
        if localRealizado.isEmpty {
            errors.append("Local realizado é obrigatório")
        }
        
        if medicoSolicitante.isEmpty {
            errors.append("Médico solicitante é obrigatório")
        }
        
        if motivoQueixa.isEmpty {
            errors.append("Motivo/queixa é obrigatório")
        }
        
        return errors
    }
}

// MARK: - ExameModel + Firebase

extension ExameModel {
    /// Converts the model to a dictionary for Firebase Firestore
    /// - Returns: Dictionary representation compatible with Firestore
    func toFirestoreDictionary() -> [String: Any] {
        var dict: [String: Any] = [
            CodingKeys.id.rawValue: id,
            CodingKeys.nome.rawValue: nome,
            CodingKeys.localRealizado.rawValue: localRealizado,
            CodingKeys.medicoSolicitante.rawValue: medicoSolicitante,
            CodingKeys.motivoQueixa.rawValue: motivoQueixa,
            CodingKeys.dataCadastro.rawValue: dataCadastro
        ]
        
        if let url = urlArquivo {
            dict[CodingKeys.urlArquivo.rawValue] = url
        }
        
        return dict
    }
    
    /// Creates an ExameModel from a Firestore dictionary
    /// - Parameter dictionary: Dictionary from Firestore
    /// - Returns: ExameModel instance or nil if parsing fails
    static func fromFirestoreDictionary(_ dictionary: [String: Any]) -> ExameModel? {
        guard
            let id = dictionary[CodingKeys.id.rawValue] as? String,
            let nome = dictionary[CodingKeys.nome.rawValue] as? String,
            let localRealizado = dictionary[CodingKeys.localRealizado.rawValue] as? String,
            let medicoSolicitante = dictionary[CodingKeys.medicoSolicitante.rawValue] as? String,
            let motivoQueixa = dictionary[CodingKeys.motivoQueixa.rawValue] as? String,
            let dataCadastro = dictionary[CodingKeys.dataCadastro.rawValue] as? Date
        else {
            return nil
        }
        
        let urlArquivo = dictionary[CodingKeys.urlArquivo.rawValue] as? String
        
        return ExameModel(
            id: id,
            nome: nome,
            localRealizado: localRealizado,
            medicoSolicitante: medicoSolicitante,
            motivoQueixa: motivoQueixa,
            dataCadastro: dataCadastro,
            urlArquivo: urlArquivo
        )
    }
}

